#!/usr/bin/env -S uv run --script --no-project

# /// script
# requires-python = ">=3.10"
# dependencies = [
#     "PyYAML",
# ]
# ///

# Copyright 2025 Canonical Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Run interface tests for the specified target, see CLI help for details."""

import argparse
import contextlib
import dataclasses
import logging
import os
import pathlib
import subprocess
import sys
import tempfile

import yaml

# TODO: release a new version of pytest-interface-tester with the features we need
_INTERFACE_TESTER_DEPENDENCY = 'git+https://github.com/james-garner-canonical/pytest-interface-tester@25-09+feat+location-customization-for-charmlibs'
# paths in this repo
_REPO_ROOT = pathlib.Path(__file__).parent.parent
_INTERFACES = _REPO_ROOT / 'interfaces'
# modules to write to
_PLUGIN_MODULE = 'interface_tester_report_plugin'
_SCHEMA_MODULE = 'interface_tester_schema_module'
# file content to write
_PLUGIN_CONTENT = '''
"""Pytest extension to annotate nodes with test outcome.

Used in dynamically generated interface test suite.
"""

import pytest


@pytest.hookimpl(tryfirst=True, hookwrapper=True)
def pytest_runtest_makereport(item, call):
    """Attach outcome report to test node."""
    outcome = yield
    report = outcome.get_result()
    if report.when == "call":
        setattr(item, "report", report)
'''.strip()
_TEST_CONTENT = '''
"""Dynamically generated interface test suite.

Created by: {script_path}
"""

# BEGIN: contents of {tests_path}

{tests_content}

# END: contents of {tests_path}

# BEGIN: dynamically templated content

import contextlib

import interface_tester
import pytest

import {schema_module}  # added to charm root dynamically


class InterfaceTesterCleanup(Exception):
    """Exception to trigger interface tester context cleanup."""


@pytest.fixture(scope='function', autouse=True)
def autogenerated_fixture_to_configure_interface_tester(
    {fixture_id}: interface_tester.InterfaceTester,
    request: pytest.FixtureRequest,
):
    """Configure charm-specified InterfaceTester fixture and setup/teardown Tester context."""
    {fixture_id}.configure(
        interface_name='{interface}',
        interface_version={version},
        repo='{repo}',
        branch='{branch}',
        interface_subdir='interface',
        tests_dir='tests',
    )
    with contextlib.suppress(InterfaceTesterCleanup):  # so fixture doesn't error
        with {fixture_id}.context(
            test_fn=request.function,
            role='{role}',
            schema=getattr({schema_module}, '{role}'.capitalize() + 'Schema'),
            endpoint='{endpoint}',
        ):
            yield  # test executes here
            # status added to node by custom pytest extension
            # added to charm root dynamically in {plugin_module}.py
            if getattr(request.node, 'report').failed:
                raise InterfaceTesterCleanup()

# END: dynamically templated content
'''.strip()

logger = logging.getLogger(str(pathlib.Path(__file__).relative_to(_REPO_ROOT)))


@dataclasses.dataclass
class _Target:
    """Testable target defined by the arguments to this script.

    See the CLI help for more on the individual arguments.
    """

    interface_name: str
    interface_version: str
    role: str
    charm_name: str
    endpoint: str

    def __post_init__(self):
        self.interface_dir = (
            _INTERFACES / self.interface_name / 'interface' / self.interface_version
        )
        self.interface_tests_path = self.interface_dir / 'tests' / f'test_{self.role}r.py'
        self.charm_config = self._load_charm_config()
        self.test_config = self.charm_config.get('test_setup', {})

    def _load_charm_config(self):
        """Load config for the current interface, role, and charm.

        It is an error if the charm config doesn't exist or is defined more than once.
        """
        interface_yaml = yaml.safe_load((self.interface_dir / 'interface.yaml').read_text())
        charms = interface_yaml[f'{self.role}rs']
        [charm_config] = [c for c in charms if c['name'] == self.charm_name]
        logger.info('Charm config: %s', charm_config)
        return charm_config


def _main() -> None:
    logging.basicConfig(level=logging.DEBUG)
    parser = argparse.ArgumentParser()
    parser.add_argument('name', help='The interface name.')
    parser.add_argument('version', help='The interface version, e.g. `v2`.')
    parser.add_argument('role', choices=('provide', 'require'))
    parser.add_argument('charm_name', help="Used to load the charm's interface test config.")
    parser.add_argument('endpoint', help='A valid endpoint for the charm + role + interface.')
    parser.add_argument('--keep', action='store_true', help="Don't delete cloned charm dir.")
    args = parser.parse_args()
    target = _Target(
        interface_name=args.name,
        interface_version=args.version,
        role=args.role,
        charm_name=args.charm_name,
        endpoint=args.endpoint,
    )
    returncode = _interface_tests(target, keep_tempdir=args.keep)
    sys.exit(returncode)


def _interface_tests(target: _Target, keep_tempdir: bool = False) -> int:
    """Run interface tests for specified interface / version / role / charm / endpoint.

    Executes the following steps:
        - Reads charm metadata from interface config.
        - Clones the charm from the specified location.
        - Writes test files and additional modules to cloned charm repo.
        - Executes tests with pytest.
    """
    # write and execute interface tester file in cloned charm repo
    with _clone_charm_repo(target.charm_config, keep_tempdir=keep_tempdir) as charm_root:
        charm_test_file = _write_charm_test_file(target, charm_root=charm_root)
        # create schema and plugin modules at charm root (included in PYTHONPATH)
        (charm_root / f'{_SCHEMA_MODULE}.py').symlink_to(target.interface_dir / 'schema.py')
        (charm_root / f'{_PLUGIN_MODULE}.py').write_text(_PLUGIN_CONTENT)
        # generate requirements.txt file
        if pre_run := target.test_config.get('pre_run'):
            logger.info(pre_run)
            subprocess.check_call(pre_run, shell=True, cwd=charm_root)  # noqa: S602
        # execute interface tests
        pytest = [
            'uvx',
            '--with=setuptools',
            f'--with={_INTERFACE_TESTER_DEPENDENCY}',
            '--with-requirements=requirements.txt',
            'pytest',
            '-p',
            _PLUGIN_MODULE,
            charm_test_file,
        ]
        logger.info(pytest)
        env = {'PYTHONPATH': '.:src:lib'}
        logger.info(env)
        completed_process = subprocess.run(pytest, env={**os.environ, **env}, cwd=charm_root)
        return completed_process.returncode


@contextlib.contextmanager
def _clone_charm_repo(charm_config: dict[str, str], keep_tempdir: bool = False):
    """Clone the charm repo to a temporary directory and yield the charm root path."""
    with tempfile.TemporaryDirectory(delete=not keep_tempdir) as td:
        repo_path = pathlib.Path(td, 'charm-repo')
        cmd: list[str | pathlib.Path] = ['git', 'clone', '--depth', '1']
        if branch := charm_config.get('branch'):
            cmd.extend(['--branch', branch])
        cmd.extend([charm_config['url'], repo_path])
        logger.info(cmd)
        subprocess.check_call(cmd, cwd=td)
        test_setup = charm_config.get('test_setup', {})
        charm_root = test_setup.get('charm_root', '')  # pyright: ignore[reportAttributeAccessIssue]
        yield repo_path / charm_root


def _write_charm_test_file(target: _Target, charm_root: pathlib.Path) -> pathlib.Path:
    """Write interface test suite and fixture for target to charm test directory."""
    test_content = _TEST_CONTENT.format(
        script_path=pathlib.Path(__file__).relative_to(_REPO_ROOT),
        tests_path=target.interface_tests_path.relative_to(_REPO_ROOT),
        tests_content=target.interface_tests_path.read_text(),
        schema_module=_SCHEMA_MODULE,
        plugin_module=_PLUGIN_MODULE,
        interface=target.interface_name,
        version=target.interface_version.removeprefix('v'),
        repo=_REPO_ROOT,
        branch=_current_branch(),
        fixture_id=target.test_config.get('identifier', 'interface_tester'),
        role=f'{target.role}r',
        endpoint=target.endpoint,
    )
    charm_test_dir = (
        charm_root / target.test_config.get('location', 'tests/interface_tests/conftest.py')
    ).parent
    charm_test_file = (
        charm_test_dir
        / f'test_{target.role}s_{_normalized(target.interface_name)}_{target.interface_version}_over_{_normalized(target.endpoint)}_endpoint.py'  # noqa: E501
    )
    charm_test_file.write_text(test_content)
    return charm_test_file


def _normalized(name: str) -> str:
    """Replace hyphens with underscores for Python module names."""
    return name.replace('-', '_')


def _current_branch() -> str:
    """Return the current git branch."""
    cmd = ['git', 'branch', '--show-current']
    return subprocess.check_output(cmd, text=True, cwd=_REPO_ROOT).strip()


if __name__ == '__main__':
    _main()
